/*  Vector field and other functions for Auto continuer.
   This code was automatically generated by PyDSTool, but may be modified by hand. */

#include "auto_f2c.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "autovfield.h"
#include "auto_c.h"

double *gICs;
double **gBds;
double globalt0;

static double pi = 3.1415926535897931;


/* Variable, parameter, and input definitions: */ 
#define G_tot	p_[0]
#define K_P2	p_[1]
#define K_P3	p_[2]
#define K_b	p_[3]
#define K_d1	p_[4]
#define K_d2	p_[5]
#define K_d3	p_[6]
#define K_d5	p_[7]
#define K_m1	p_[8]
#define K_m2	p_[9]
#define K_m3	p_[50]
#define V_S2	p_[51]
#define V_S3	p_[52]
#define V_S4	p_[53]
#define V_S5	p_[54]
#define k1	p_[55]
#define k_i	p_[56]
#define k_stress	p_[57]
#define n1	p_[58]
#define n2	p_[59]
#define _T	p_[10]
#define ACTH	Y_[0]
#define CORT	Y_[1]
#define CRH	Y_[2]
#define GR	Y_[3]


int heav(double x_, double *p_, double *wk_, double *xv_);
double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_);
double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_);
double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_);
double initcond(char *varname, double *p_, double *wk_, double *xv_);
int getindex(char *name, double *p_, double *wk_, double *xv_);
double globalindepvar(double t, double *p_, double *wk_, double *xv_);
double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_);

void auxvars(unsigned, unsigned, double, double*, double*, double*, unsigned, double*, unsigned, double*);
void jacobian(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
void jacobianParam(unsigned, unsigned, double, double*, double*, double**, unsigned, double*, unsigned, double*);
int N_AUXVARS = 0;


void vfieldfunc(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){

f_[0] = K_P2*CRH*(pow(k_i,n2)/(pow(k_i,n2)+pow(GR,n2)))-V_S4*(ACTH/(K_m2+ACTH))-K_d2*ACTH;
f_[1] = K_P3*ACTH-V_S5*(CORT/(K_m3+CORT))-K_d3*CORT;
f_[2] = k_stress*(pow(k_i,n2)/(pow(k_i,n2)+pow(GR,n2)))-V_S3*(CRH/(K_m1+CRH))-K_d1*CRH;
f_[3] = K_b*CORT*(G_tot-GR)+V_S2*(pow(GR,n1)/(pow(k1,n1)+pow(GR,n1)))-K_d5*GR;

}




int heav(double x_, double *p_, double *wk_, double *xv_) {
  if (x_>0.0) {return 1;} else {return 0;}
}


double __rhs_if(int cond_, double e1_, double e2_, double *p_, double *wk_, double *xv_) {
  if (cond_) {return e1_;} else {return e2_;};
}


double __maxof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ > e2_) {return e1_;} else {return e2_;};
}


double __minof2(double e1_, double e2_, double *p_, double *wk_, double *xv_) {
if (e1_ < e2_) {return e1_;} else {return e2_;};
}


double __maxof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {return e3_;} else {return temp_;};
}


double __minof3(double e1_, double e2_, double e3_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {return e3_;} else {return temp_;};
}


double __maxof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ > e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ > temp_) {temp_ = e3_;};
if (e4_ > temp_) {return e4_;} else {return temp_;};
}


double __minof4(double e1_, double e2_, double e3_, double e4_, double *p_, double *wk_, double *xv_) {
double temp_;
if (e1_ < e2_) {temp_ = e1_;} else {temp_ = e2_;};
if (e3_ < temp_) {temp_ = e3_;};
if (e4_ < temp_) {return e4_;} else {return temp_;};
}


double initcond(char *varname, double *p_, double *wk_, double *xv_) {

  if (strcmp(varname, "ACTH")==0)
	return gICs[0];
  else if (strcmp(varname, "CORT")==0)
	return gICs[1];
  else if (strcmp(varname, "CRH")==0)
	return gICs[2];
  else if (strcmp(varname, "GR")==0)
	return gICs[3];
  else {
	fprintf(stderr, "Invalid variable name %s for initcond call\n", varname);
	return 0.0/0.0;
	}
}


int getindex(char *name, double *p_, double *wk_, double *xv_) {

  if (strcmp(name, "ACTH")==0)
	return 0;
  else if (strcmp(name, "CORT")==0)
	return 1;
  else if (strcmp(name, "CRH")==0)
	return 2;
  else if (strcmp(name, "GR")==0)
	return 3;
  else if (strcmp(name, "G_tot")==0)
	return 4;
  else if (strcmp(name, "K_P2")==0)
	return 5;
  else if (strcmp(name, "K_P3")==0)
	return 6;
  else if (strcmp(name, "K_b")==0)
	return 7;
  else if (strcmp(name, "K_d1")==0)
	return 8;
  else if (strcmp(name, "K_d2")==0)
	return 9;
  else if (strcmp(name, "K_d3")==0)
	return 10;
  else if (strcmp(name, "K_d5")==0)
	return 11;
  else if (strcmp(name, "K_m1")==0)
	return 12;
  else if (strcmp(name, "K_m2")==0)
	return 13;
  else if (strcmp(name, "K_m3")==0)
	return 14;
  else if (strcmp(name, "V_S2")==0)
	return 15;
  else if (strcmp(name, "V_S3")==0)
	return 16;
  else if (strcmp(name, "V_S4")==0)
	return 17;
  else if (strcmp(name, "V_S5")==0)
	return 18;
  else if (strcmp(name, "k1")==0)
	return 19;
  else if (strcmp(name, "k_i")==0)
	return 20;
  else if (strcmp(name, "k_stress")==0)
	return 21;
  else if (strcmp(name, "n1")==0)
	return 22;
  else if (strcmp(name, "n2")==0)
	return 23;
  else {
	fprintf(stderr, "Invalid name %s for getindex call\n", name);
	return 0.0/0.0;
	}
}


double globalindepvar(double t, double *p_, double *wk_, double *xv_) {
  return globalt0+t;
}


double getbound(char *name, int which_bd, double *p_, double *wk_, double *xv_) {
  return gBds[which_bd][getindex(name, p_, wk_, xv_)];
}

void auxvars(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double *f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_){


}


void jacobian(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}

void jacobianParam(unsigned n_, unsigned np_, double t, double *Y_, double *p_, double **f_, unsigned wkn_, double *wk_, unsigned xvn_, double *xv_) {
}
